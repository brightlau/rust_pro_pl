/* std::io 标准输入输出库，默认情况 rust 会预导入设定的一些标准库到程序的作用域中，可以在标准库文档中查看。
如果需要的库类型不在预导入的设定中（如 io::stdin），则需要使用 use 显示的引入其程序的作用域中。*/
use std::io;

/**
 * 一、宏调用
 * 在 Rust 中，println! 和 print! 都是宏（都带 ! 符号），Rust 标准库中没有名为 println 或 print 的函数
 * 
 *  // ✅ 正确的宏调用（带感叹号）
 *  println!("Hello World"); 
 *  print!("Rust ");
 *
 *  // ❌ 以下写法都会编译失败（不存在这些函数）
 *  // println("Missing bang!");  // 错误：找不到 `println` 函数
 *  // print(42);                 // 错误：找不到 `print` 函数
 * 
 * 
 * 总结关键点：在 Rust 中，所有格式化输出操作都通过宏实现，! 是宏调用的必须标记。这种设计使得 Rust 能在编译期完成格式验证和代码生成，既保证了类型安全，又提升了运行时性能。
 * 
 * 二、Rust 的 println! 宏与 C/C++ 的 printf 函数的对比分析
 * 从 优势 和 缺点 两个角度展开
 * 
 * 优势：
 * 
 * 1. 类型安全（Type Safety）
 *  // Rust（编译时检查类型）
 *  let x = 10;
 *  println!("Number: {}", x);          // ✅ 正确
 *  // println!("Number: {}", "text");  // ❌ 编译错误：类型不匹配
 *  
 *  // C（运行时可能崩溃）
 *  int x = 10;
 *  printf("Number: %d", x);           // ✅
 *  printf("Number: %d", "text");      // ❌ 未定义行为（UB），可能导致崩溃
 * Rust：宏在编译时检查参数类型与格式字符串的匹配性，完全杜绝类型错误
 * C/C++：依赖程序员手动保证类型匹配，错误会导致未定义行为
 * 
 * 2. 内存安全（Memory Safety）
 *  // Rust 自动处理内存分配
 *  println!("{}", "hello");           // 字符串直接传递，无内存管理负担
 *  
 *  // C 需要手动管理内存
 *  char* s = malloc(6); 
 *  strcpy(s, "hello");
 *  printf("%s", s);                   // 需要确保 s 有效且以 '\0' 结尾
 *  free(s);                           // 必须手动释放内存
 * Rust：无悬垂指针、缓冲区溢出风险
 * C/C++：存在内存泄漏、越界访问等风险
 * 
 * 3. 语法灵活性
 *  // Rust 自动推导显示方式
 *  println!("Debug: {:?}", vec![1, 2]);  // 自动调用 Debug trait
 *  println!("Display: {}", 3.14);        // 自动调用 Display trait
 *  
 *  // C 需要明确格式化符号
 *  printf("Int: %d, Float: %f", 10, 3.14);  // 必须严格指定 %d/%f
 * Rust：通过 {} 自动选择 trait，支持自定义格式（如 {:.2} 保留两位小数）
 * C/C++：格式符号（%d, %s）固定，灵活性差
 * 
 * 4. 性能优化
 *  // println! 宏展开为直接调用底层 IO 函数
 *  ::std::io::_print(format_args!("Value: {}", x));
 *  
 *  // C 的 printf 需要运行时解析格式字符串
 *  printf("Value: %d", x);  // 需要运行时解析 %d
 * Rust：编译期展开宏，生成直接操作 IO 的高效代码
 * C/C++：运行时解析格式字符串，有一定性能开销
 * 
 * 缺点：
 * 
 * 1. 编译错误信息复杂度
 *  // Rust 的错误信息可能较复杂
 *  println!("Missing: {}");  // 错误：缺少参数，但提示涉及宏展开细节
 *  
 *  // C 的错误更直观（但可能延迟到运行时）
 *  printf("Missing: %d");    // 编译通过，运行时崩溃
 * Rust：宏错误信息可能包含底层展开细节，对新手不友好
 * C/C++：简单的语法错误更易发现（但严重错误会延迟到运行时）
 * 
 * 2. 格式化能力差异
 *  // Rust 的格式化选项（部分示例）
 *  println!("Hex: {:x}, Binary: {:b}", 255, 15);  // 十六进制和二进制
 *  println!("Align: {:<10}", "left");             // 左对齐填充
 *  
 *  // C 的复杂格式化
 *  printf("%-10s", "left");    // 左对齐填充
 *  printf("%#x", 255);         // 十六进制带前缀
 * Rust：功能与 C 基本相当，但语法不同（需要学习新的格式规则）
 * C/C++：某些高级格式（如 %n 写入已输出字符数）在 Rust 中不提供
 * 
 * 3. 跨语言一致性
 *  // Rust 的格式化是语言内置特性
 *  println!("{}", 42);  // 依赖 Rust 的 trait 系统
 *  
 *  // C 的 printf 是标准库函数
 *  printf("%d", 42);    // 所有 C 编译器统一支持
 * Rust：格式化行为与语言特性（如 trait）深度绑定
 * C/C++：格式化函数是标准库的一部分，不同编译器行为一致 
 * 
 * 总结对比表：
 *  特性	                Rust println! 宏	                C/C++ printf 函数
 *  类型安全	            编译时强制检查，零运行时风险	        无检查，可能导致未定义行为
 *  内存安全	            无手动内存管理，杜绝缓冲区溢出	        需手动管理内存
 *  性能	                编译期优化，无运行时解析开销	        运行时解析格式字符串
 *  错误反馈	            编译时报错（错误信息可能复杂）	        部分错误延迟到运行时
 *  格式化灵活性	         通过 trait 系统扩展，支持自定义类型	    格式符号固定，但部分高级功能独特
 *  跨平台一致性	         依赖 Rust 编译器版本	               遵循 C 标准，不同编译器行为一致
 * 
 * 建议：
 * 选择 Rust println! 当：
 *  需要绝对的类型/内存安全
 *  追求高性能输出
 *  处理自定义类型的格式化
 * 
 * 选择 C printf 当：
 *  需要与现有 C 代码交互
 *  依赖某些特有的格式符号（如 %n）
 *  目标环境无法使用 Rust 工具链
 * 
 * 三、C/C++ 社区针对 printf 这类格式化函数的缺陷，发展出了多种应对方案。这些方案各有利弊
 * 
 * 1. 静态分析与编译器增强
 *  gcc/clang 的格式化字符串检查 编译器警告 `gcc -Wformat=2 test.c`
 *  clang 的 __attribute__ 扩展 对自定义的函数添加格式检查 `void safe_printf(const char* fmt, ...) __attribute__((format(printf, 1, 2)));`
 * 
 * 2. 现代 c++ 类型安全替代方案
 *  使用 iostream 牺牲性能换安全
 *  C++ 20 的 std::format 库
 * 
 * 3. 运行时保护机制
 *  编译时启动加固 `gcc -O2 -D_FORTIFY_SOURCE=2 test.c`
 *  动态格式化字符串校验 自定义安装封装 va_list、va_start va_end
 * 
 * 4. 代码规范与工具链
 *  MISRA C 规范 禁止使用可变参数函数
 *  静态分析工具使用 clang-tidy
 * 
 * 5. 各领域专用方案
 *  嵌入式系统 LOG 宏
 *  元编程生成安全代码 C++ 模板
 *  
 * C/C++ 社区通过以下方式缓解格式化缺陷
 * 
 *  分层防御：
 *  编译时：静态分析 + 编译器扩展
 *  编码时：规范约束 + 安全抽象层
 *  运行时：加固机制 + 动态校验
 *  
 *  代价权衡：
 *  安全增强 ↔ 性能损失
 *  灵活性 ↔ 代码复杂度
 * 
 *  遗留问题：
 *   动态格式字符串（如 printf(argv[1])）仍无法完全防御
 *   旧代码库改造困难
 * 
 * 最终，这些方案只能 减轻 而无法 根除 问题，这也是 Rust 等现代语言强调内存安全和编译时检查的原因。
 * 对于新项目，在允许的情况下，优先选用类型安全的替代方案（如 C++20 的 std::format）是更优选择
 * 
 * 四、C++ 选择引入 std::format 而非扩展宏来实现类型安全的格式化，是基于其语言设计哲学、历史兼容性和现代编程范式的权衡
 * 
 * 1. 语言设计哲学差异：C++ 的「零开销抽象」原则
 *  std::format 的优势 
 *   std::string s = std::format("Value: {}", 42);  // 编译时类型检查 + 高效代码生成，类型安全，性能接近 printf
 *   通过模板和 constexpr 实现编译时解析，无运行时开销，避免宏的文本替换机制（可能引入意外副作用）
 *  C++ 宏的局限性
 *   C++ 宏系统缺乏对参数类型的直接访问能力，难以在预处理阶段实现复杂的类型推导和格式验证
 * 
 * 2. 类型系统的实现方式：
 *   C++ 的类型推导依赖模板
 *    template<typename... Args>
 *    std::string format(std::string_view fmt, Args&&... args) {
 *        // 编译时校验格式字符串与参数类型
 *        check_format<Args...>(fmt); 
 *        // ...
 *    }
 *   优势：利用模板特化和 constexpr 函数在编译期完成格式校验
 *   对比宏：宏无法直接操作类型信息，需依赖外部工具（如静态分析器）补充检查  
 * 
 *   Rust 宏的先天优势
 *    // Rust 宏可直接操作抽象语法树（AST）
 *    macro_rules! safe_print {
 *        ($($arg:expr),*) => {{
 *            // 编译器可访问所有表达式的类型信息
 *            println!("{}", format_args!($($arg),*))
 *        }};
 *    }
 *   语言级支持：Rust 宏是语言的一等公民，深度集成类型系统
 *   C++ 的限制：预处理宏在语法分析前展开，无法与类型系统交互
 * 
 * 3. 历史兼容性与生态影响
 *   避免破坏现有代码
 *     printf 的广泛使用：直接引入新宏可能导致与现有宏的命名冲突、std::format 作为库特性，可渐进式迁移
 *   标准化流程的权衡
 *     委员会决策：C++ 标准委员会更倾向于库解决方案，因其：不修改语言核心语法，更容易实现跨编译器兼容，避免宏的调试复杂性（如 -E 预处理后的代码难以阅读）
 * 
 * 4. 现代 C++ 的特性支持
 *   利用 constexpr 和模板元编程
 *    // 编译时格式字符串解析
 *    constexpr auto fmt = std::format_string<int>("Value: {}");
 *    
 *    // 生成优化代码
 *    std::string s = std::format(fmt, 42); 
 *   编译时计算：格式字符串的解析可在编译期完成，生成高效代码
 *   对比宏：无法利用 constexpr 的优化潜力
 * 
 *   扩展性设计
 *    类型安全扩展：通过模板特化实现，无需修改语言核心
 *    宏的局限性：难以实现类似的可扩展性
 * 
 * 5. 错误处理与调试友好性
 *   std::format 的编译时错误：清晰提示直接关联类型不匹配的具体位置
 *   对比宏错误：错误信息可能涉及宏展开细节，难以理解
 * 
 *   IDE 支持：库函数可被静态分析工具更好地支持（如自动补全、参数提示）宏展开后的代码对工具链不透明
 * 
 * 这一决策体现了 C++「不改语言改库」的演进哲学，在保持向后兼容的同时，通过库和模板等机制实现现代化。
 * 对于需要类似宏的元编程场景，C++ 更倾向于通过 constexpr、模板和 Concepts 等类型安全机制来实现，而非扩展预处理宏
 */

pub fn guess_fn() {
    /* println! 调用的是一个 rust 的宏，没有 ! 的调用是 rust 的一个函数。当看到符号 ! 时表示调用的是一个宏而不是函数
    宏并不总是遵循函数的规则 */
    println!("Guess a number!");

    // 输入一个猜测的数字
    println!("Please input your guess!");
    let mut guess = String::new();
    io::stdin().read_line(&mut guess).expect("failed to read line");

    println!("You guessed: {guess}");

    
}
