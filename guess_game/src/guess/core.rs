/* std::io 标准输入输出库，默认情况 rust 会预导入设定的一些标准库到程序的作用域中，可以在标准库文档中查看。
如果需要的库类型不在预导入的设定中（如 io::stdin），则需要使用 use 显示的引入其程序的作用域中。*/
use std::io;

/**
 * 一、宏调用
 * 在 Rust 中，println! 和 print! 都是宏（都带 ! 符号），Rust 标准库中没有名为 println 或 print 的函数
 * 
 *  // ✅ 正确的宏调用（带感叹号）
 *  println!("Hello World"); 
 *  print!("Rust ");
 *
 *  // ❌ 以下写法都会编译失败（不存在这些函数）
 *  // println("Missing bang!");  // 错误：找不到 `println` 函数
 *  // print(42);                 // 错误：找不到 `print` 函数
 * 
 * 总结关键点：在 Rust 中，所有格式化输出操作都通过宏实现，! 是宏调用的必须标记。这种设计使得 Rust 能在编译期完成格式验证和代码生成，既保证了类型安全，又提升了运行时性能。
 * 
 * 语言	            核心目标	                        输出机制实现思路
 * Rust	           安全 + 零成本抽象 + 元编程	         宏系统在编译期构建AST，保证安全高效
 * Go	           简单 + 快速开发 + 运行时安全	         基于反射的运行时检查，牺牲性能换安全
 * C/C++	       极简主义 + 硬件控制	                原始指针操作，信任程序员
 * 
 * 核心差异矩阵
 * 维度	            Rust (println!)	                   Go (fmt.Println)	                C/C++ (printf)
 * 类型安全	        编译期担保 (100% 安全)	              运行时检查 (安全但有损)	          无保护 (高危)
 * 性能	           零成本 (编译期优化)	                  运行时反射 (有开销)	             解析开销 (可部分优化)
 * 灵活性	       宏 + Trait (高扩展性)	             接口 + 反射 (中等)	                仅基础类型 (低)
 * 错误处理	        编译失败 (快速反馈)	                  运行时错误输出 (延迟发现)	           未定义行为 (难调试)
 * 适用场景	        系统编程 + 高性能应用	               应用开发 + 快速原型	              底层/遗留系统
 * 
 * 关键结论：
 * Rust 的 println! 通过宏系统和编译期检查，在输出领域实现了：
 * ✅ 绝对类型安全 + ✅ 零成本抽象 + ✅ 语法扩展自由
 * 这是 Rust 追求「内存安全不妥协」+「性能不妥协」的典型体现。
 * 
 * 二、let mut 变量声明
 * 
 * 特性	                    Rust	                            C/C++	                                  Go
 * 默认可变性	             默认不可变 (let)，需显式声明 mut	     默认可变，需用 const 声明不可变	           默认可变，需用 const 声明不可变（仅常量）
 * 关键字	                let（可变需 mut）	                  类型声明（如 int x）	                      var 或短声明 :=
 * 类型推断	                支持（如 let x = 5）	               C 不支持；C++11+ 支持 auto	              支持（如 x := 5）
 * 作用域	                块作用域，遵循所有权规则	             块作用域	                                块作用域
 * 必须初始化	             是（否则编译错误）	                     否（局部变量可能为垃圾值）	                   是（未初始化会赋零值）
 * 变量遮蔽（Shadowing）	 允许（同作用域可重复 let）	             C/C++ 不允许（同一作用域不可重复声明）	         允许（短声明可遮蔽外层变量）
 * 常量声明	                 const 或 static	                 const（C/C++）或 constexpr（C++11+）	     const（需编译期确定值）
 * 类型显式声明	             可选（可自动推断）	                     C 必须显式；C++ 可用 auto	                 可选（短声明 := 可推断）
 * 重新赋值	                 仅 mut 变量允许	                   默认允许（除非 const）	                    默认允许（除非 const）
 * 
 * Rust 的优势
 * 特性	           优势
 * 默认可变性	    强制显式声明可变性（mut），减少意外修改，提升代码安全性和可维护性。
 * 所有权机制	    通过作用域和所有权规则，避免内存泄漏和数据竞争，天然支持线程安全。
 * 必须初始化	    编译时强制初始化，消除未定义行为（如野指针、垃圾值）。
 * 变量遮蔽	       允许同作用域遮蔽变量，简化逻辑（如类型转换或临时变量复用），增强代码灵活性。
 * 类型推断	       无需显式类型声明（如 let x = 5），代码简洁，同时保持强类型安全。
 * 常量与静态变量	const（编译期常量）和 static（全局静态变量）分工明确，避免误用。
 * 
 * 适用场景：
 * 对安全性要求高的系统级编程（如操作系统、嵌入式）。
 * 需要严格内存管理和并发控制的场景（如高性能服务器）。
 * 
 * C/C++ 的优势
 * 特性	           优势
 * 默认可变性	    默认可变，直接操作内存，灵活性强，适合底层开发（如硬件驱动、内核）。
 * 显式类型控制	    强制显式类型声明（C）或灵活使用 auto（C++11+），精准控制内存布局和性能。
 * 手动内存管理	    直接管理内存分配/释放（如 malloc/free），适合对性能或资源有极致需求的场景。
 * 兼容性	       C/C++ 语法广泛兼容历史代码和硬件接口，生态庞大。
 * 
 * 适用场景：
 * 需要直接操作硬件或内存的底层开发（如嵌入式、游戏引擎）。
 * 高性能计算和资源受限环境（如实时系统）。
 * 
 * Go 的优势
 * 特性	           优势
 * 短声明语法	    x := 5 快速声明变量，减少冗余代码，提升开发效率。
 * 零值初始化	    未显式初始化的变量自动赋零值（如 int 为 0），避免未定义行为。
 * 类型推断	       支持隐式类型推断（:=），代码简洁，适合快速原型开发。
 * 轻量级语法	    无分号、括号简洁，语法接近现代高级语言，学习成本低。
 * 并发友好	       变量默认可跨协程共享（需通过 Channel 同步），简化并发编程。
 * 
 * 适用场景：
 * 快速开发高并发服务（如微服务、API 后端）。
 * CLI 工具或脚本类程序，强调开发速度和代码简洁性。
 * 
 * 三、String 是一个标准库提供的字符串类型，它是 UTF-8 编码的可增长文本块。
 * ::new 那一行的 :: 语法表明 new 是 String 类型的一个 关联函数（associated function）。关联函数是针对某个类型实现的函数，在这个例子中是 String。这个 new 函数创建了一个新的空字符串。你会发现许多类型上都有一个 new 函数，因为这是为某种类型创建新值的常用函数名。
 * 
 */

pub fn guess_fn() {
    /* println! 调用的是一个 rust 的宏，没有 ! 的调用是 rust 的一个函数。当看到符号 ! 时表示调用的是一个宏而不是函数
    宏并不总是遵循函数的规则 */
    println!("Guess a number!");

    // 输入一个猜测的数字
    println!("Please input your guess!");
    /* let 语句来创建变量 mut 使变量可变 
    let mut guess 会引入一个叫做 guess 的可变变量。等号（=）告诉 Rust 我们现在想将某个值绑定在变量上。
    等号的右边是 guess 所绑定的值，它是 String::new 的结果，这个函数会返回一个 String 的新实例。
    let mut guess = String::new(); 这一行创建了一个可变变量，当前它绑定到一个新的 String 空实例上。
    */
    let mut guess = String::new();
    /*
    
    */
    io::stdin().read_line(&mut guess).expect("failed to read line");

    println!("You guessed: {guess}");

    
}
