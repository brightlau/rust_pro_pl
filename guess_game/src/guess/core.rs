/* std::io 标准输入输出库，默认情况 rust 会预导入设定的一些标准库到程序的作用域中，可以在标准库文档中查看。
如果需要的库类型不在预导入的设定中（如 io::stdin），则需要使用 use 显示的引入其程序的作用域中。*/
use std::io;

/**
 * 一、宏调用
 * 在 Rust 中，println! 和 print! 都是宏（都带 ! 符号），Rust 标准库中没有名为 println 或 print 的函数
 * 
 *  // ✅ 正确的宏调用（带感叹号）
 *  println!("Hello World"); 
 *  print!("Rust ");
 *
 *  // ❌ 以下写法都会编译失败（不存在这些函数）
 *  // println("Missing bang!");  // 错误：找不到 `println` 函数
 *  // print(42);                 // 错误：找不到 `print` 函数
 * 
 * 总结关键点：在 Rust 中，所有格式化输出操作都通过宏实现，! 是宏调用的必须标记。这种设计使得 Rust 能在编译期完成格式验证和代码生成，既保证了类型安全，又提升了运行时性能。
 * 
 * 语言	            核心目标	                        输出机制实现思路
 * Rust	           安全 + 零成本抽象 + 元编程	         宏系统在编译期构建AST，保证安全高效
 * Go	           简单 + 快速开发 + 运行时安全	         基于反射的运行时检查，牺牲性能换安全
 * C/C++	       极简主义 + 硬件控制	                原始指针操作，信任程序员
 * 
 * 核心差异矩阵
 * 维度	            Rust (println!)	                   Go (fmt.Println)	                C/C++ (printf)
 * 类型安全	        编译期担保 (100% 安全)	              运行时检查 (安全但有损)	          无保护 (高危)
 * 性能	           零成本 (编译期优化)	                  运行时反射 (有开销)	             解析开销 (可部分优化)
 * 灵活性	       宏 + Trait (高扩展性)	             接口 + 反射 (中等)	                仅基础类型 (低)
 * 错误处理	        编译失败 (快速反馈)	                  运行时错误输出 (延迟发现)	           未定义行为 (难调试)
 * 适用场景	        系统编程 + 高性能应用	               应用开发 + 快速原型	              底层/遗留系统
 * 
 * 关键结论：
 * Rust 的 println! 通过宏系统和编译期检查，在输出领域实现了：
 * ✅ 绝对类型安全 + ✅ 零成本抽象 + ✅ 语法扩展自由
 * 这是 Rust 追求「内存安全不妥协」+「性能不妥协」的典型体现。
 * 
 * 二、let mut 变量声明
 * 
 * 特性	                    Rust	                            C/C++	                                  Go
 * 默认可变性	             默认不可变 (let)，需显式声明 mut	     默认可变，需用 const 声明不可变	           默认可变，需用 const 声明不可变（仅常量）
 * 关键字	                let（可变需 mut）	                  类型声明（如 int x）	                      var 或短声明 :=
 * 类型推断	                支持（如 let x = 5）	               C 不支持；C++11+ 支持 auto	              支持（如 x := 5）
 * 作用域	                块作用域，遵循所有权规则	             块作用域	                                块作用域
 * 必须初始化	             是（否则编译错误）	                     否（局部变量可能为垃圾值）	                   是（未初始化会赋零值）
 * 变量遮蔽（Shadowing）	 允许（同作用域可重复 let）	             C/C++ 不允许（同一作用域不可重复声明）	         允许（短声明可遮蔽外层变量）
 * 常量声明	                 const 或 static	                 const（C/C++）或 constexpr（C++11+）	     const（需编译期确定值）
 * 类型显式声明	             可选（可自动推断）	                     C 必须显式；C++ 可用 auto	                 可选（短声明 := 可推断）
 * 重新赋值	                 仅 mut 变量允许	                   默认允许（除非 const）	                    默认允许（除非 const）
 * 
 * Rust 的优势
 * 特性	           优势
 * 默认可变性	    强制显式声明可变性（mut），减少意外修改，提升代码安全性和可维护性。
 * 所有权机制	    通过作用域和所有权规则，避免内存泄漏和数据竞争，天然支持线程安全。
 * 必须初始化	    编译时强制初始化，消除未定义行为（如野指针、垃圾值）。
 * 变量遮蔽	       允许同作用域遮蔽变量，简化逻辑（如类型转换或临时变量复用），增强代码灵活性。
 * 类型推断	       无需显式类型声明（如 let x = 5），代码简洁，同时保持强类型安全。
 * 常量与静态变量	const（编译期常量）和 static（全局静态变量）分工明确，避免误用。
 * 
 * 适用场景：
 * 对安全性要求高的系统级编程（如操作系统、嵌入式）。
 * 需要严格内存管理和并发控制的场景（如高性能服务器）。
 * 
 * C/C++ 的优势
 * 特性	           优势
 * 默认可变性	    默认可变，直接操作内存，灵活性强，适合底层开发（如硬件驱动、内核）。
 * 显式类型控制	    强制显式类型声明（C）或灵活使用 auto（C++11+），精准控制内存布局和性能。
 * 手动内存管理	    直接管理内存分配/释放（如 malloc/free），适合对性能或资源有极致需求的场景。
 * 兼容性	       C/C++ 语法广泛兼容历史代码和硬件接口，生态庞大。
 * 
 * 适用场景：
 * 需要直接操作硬件或内存的底层开发（如嵌入式、游戏引擎）。
 * 高性能计算和资源受限环境（如实时系统）。
 * 
 * Go 的优势
 * 特性	           优势
 * 短声明语法	    x := 5 快速声明变量，减少冗余代码，提升开发效率。
 * 零值初始化	    未显式初始化的变量自动赋零值（如 int 为 0），避免未定义行为。
 * 类型推断	       支持隐式类型推断（:=），代码简洁，适合快速原型开发。
 * 轻量级语法	    无分号、括号简洁，语法接近现代高级语言，学习成本低。
 * 并发友好	       变量默认可跨协程共享（需通过 Channel 同步），简化并发编程。
 * 
 * 适用场景：
 * 快速开发高并发服务（如微服务、API 后端）。
 * CLI 工具或脚本类程序，强调开发速度和代码简洁性。
 * 
 * 三、String 是一个标准库提供的字符串类型，它是 UTF-8 编码的可增长文本块。
 * ::new 那一行的 :: 语法表明 new 是 String 类型的一个 关联函数（associated function）。关联函数是针对某个类型实现的函数，在这个例子中是 String。这个 new 函数创建了一个新的空字符串。你会发现许多类型上都有一个 new 函数，因为这是为某种类型创建新值的常用函数名。
 * 
 * 字符串类型对比表
 * 维度	            Rust	                                    C/C++	                                                Go
 * 核心类型	        String（堆分配，可变）、&str（字符串切片，不可变）	std::string（C++，堆/栈管理）、char[]（C，栈或堆分配）  	   string（不可变，UTF-8 编码）
 * 内存管理	        所有权机制 + 借用检查，编译时确保无悬垂指针	        C++：RAII（自动释放）；C：手动管理（malloc/free）	         垃圾回收（GC）自动管理
 * 可变性	        String 可变，&str 不可变	                   std::string 可变；char[] 可变	                       不可变（修改需创建新字符串）
 * 编码支持	        默认 UTF-8，强制检查无效字节	                 无内置编码处理（依赖开发者）	                            原生 UTF-8，支持 Unicode 字符（如 rune 类型）
 * 性能特点	        零成本抽象，无 GC 开销	                        极致优化（如 SSO、移动语义）	                            不可变性牺牲部分性能，GC 可能引入延迟
 * 线程安全	        通过 Send/Sync 标记保证线程安全	                需手动同步（如互斥锁）	                                    不可变性天然线程安全
 * 安全性	        编译时防止悬垂指针、数据竞争	                 依赖开发者经验（易出现内存泄漏、悬垂指针）	                    运行时 GC 防止内存泄漏，但无编译时检查
 * 常用操作	        方法丰富（如 push_str、replace），需注意所有权	   C++：append、substr 等；C：strcat、strcpy（易出错）	      简单操作（如 + 拼接、len 获取长度），需注意不可变性
 * 典型问题	        学习曲线陡峭（需理解所有权）	                  C++：迭代器失效；C：缓冲区溢出、内存泄漏	                    频繁拼接性能差（需 strings.Builder）
 * 设计哲学	        安全性与性能并重	                            灵活性与控制力优先	                                       简单性与开发效率优先
 * 
 * 关键差异总结
 * 内存安全：
 * Rust：编译时保证无内存错误（如悬垂指针、越界访问）。
 * C/C++：依赖开发者经验，易出现内存泄漏或越界。
 * Go：GC 管理内存，但无法避免运行时开销。
 * 字符串可变性：
 * Rust：通过 String 和 &str 分离可变性与不可变性。
 * C/C++：直接修改内容（如 std::string::append）。
 * Go：严格不可变，修改需创建新对象。
 * 性能优化：
 * Rust/C++：支持 SSO（短字符串优化）、避免冗余拷贝。
 * Go：不可变性简化设计，但高频操作需依赖 strings.Builder。
 * 编码处理：
 * Rust/Go：强制 UTF-8，避免乱码。
 * C/C++：无内置编码支持（需手动处理多字节字符）
 * 
 */

pub fn guess_fn() {
    /* println! 调用的是一个 rust 的宏，没有 ! 的调用是 rust 的一个函数。当看到符号 ! 时表示调用的是一个宏而不是函数
    宏并不总是遵循函数的规则 */
    println!("Guess a number!");

    // 输入一个猜测的数字
    println!("Please input your guess!");
    /* let 语句来创建变量 mut 使变量可变 
    let mut guess 会引入一个叫做 guess 的可变变量。等号（=）告诉 Rust 我们现在想将某个值绑定在变量上。
    等号的右边是 guess 所绑定的值，它是 String::new 的结果，这个函数会返回一个 String 的新实例。
    let mut guess = String::new(); 这一行创建了一个可变变量，当前它绑定到一个新的 String 空实例上。
    */
    let mut guess = String::new();
    /*
    在程序的第一行使用 use std::io; 从标准库中引入了输入/输出功能。现在调用 io 库中的函数 stdin，这允许我们处理用户输入，等价 std::io::stdin <=> use std::io; io::stdin()
    stdin 函数返回一个 std::io::Stdin 的实例，这是一种代表终端标准输入句柄的类型。
    .read_line(&mut guess) 调用了标准输入句柄上的 read_line 方法，以获取用户输入，将 &mut guess 作为参数传递给 read_line 函数，让其将用户输入储存到这个字符串中。
    read_line 的工作是，无论用户在标准输入中键入什么内容，都将其追加（不会覆盖其原有内容）到一个字符串中，因此它需要字符串作为参数。这个字符串参数应该是可变的，以便 read_line 将用户输入附加上去

    & 表示这个参数是一个 引用（reference），它允许多处代码访问同一处数据，而无需在内存中多次拷贝。引用是一个复杂的特性，Rust 的一个主要优势就是安全而简单的操纵引用。

    使用 Result 类型来处理潜在的错误。
    */
    io::stdin().read_line(&mut guess).expect("failed to read line");

    println!("You guessed: {guess}");

    
}
